#' Visualize the overlap result by heatmap.
#'
#' This function generates a heatmap to visualize the overlap result between different gene sets.
#'
#' @param ovlp A square matrix generated by \code{\link{OverlapMat}}, representing the overlap scores between gene sets.
#' @param cut.num Number of clusters to cut the heatmap, if provided, the heatmap will be clustered based on the given number of clusters and
#' return will be a list contained a Heatmap and cluster result.
#' @param border Color of the heatmap borders.
#' @param method.clustering The clustering method. Possible values
#' are all the methods supported by \code{\link[stats]{hclust}} such as \code{"ward.D2"}, \code{"single"}, \code{"average"}, etc. Default is \code{"ward.D2"}.
#' @param distance.clustering The distance measure used for clustering. Possible values are \code{"Intersection"} for intersection between two programs as similarity, 
#' \code{"Jaccard"} for Jaccard similarity, 
#' \code{"correlation"} for Pearson correlation and all the distances supported by \code{\link[stats]{dist}}, such as \code{"euclidean"}, etc.
#' Default is \code{"Intersection"}. If this parameter is set as \code{"Jaccard"}, the \code{Jaccard} parameter in \code{\link{OverlapMat}} should be set as \code{TRUE}.
#' @param max.intersect When the \code{"distance.clustering"} is set to \code{"Intersection"}, the distance between two programs will be calculate as the difference of \code{max.intersect} and \code{intersection}. Default is 50.
#' @param annotation A data.frame containing additional annotations to be shown as row annotations on the heatmap, default is NA.
#' @param color.annotation A list of colors to be used for the annotations, default is NA. The names of this list should match with the colnames of annotation data.frame
#' @param cluster.name The name of the cluster column in the annotation data.frame, default is 'MetaProgram'.
#' @param cluster.key The prefix for the cluster names, default is 'MP_'.
#' @param name The name of the heatmap legend, default is 'Share Genes'.
#' @param show.colnames A logical value indicates whether column names are be shown.
#' @param breaks A numeric vector indicates the breakpoints for the color scale of the heatmap.
#' @param color The colors to be used for the heatmap.
#' @param ... Additional arguments to be passed to \code{ComplexHeatmap::\link[ComplexHeatmap]{pheatmap}}.
#'
#' @return When the \code{cut.num} is provided, a list contains 2 element: Heatmap and Cluster will be returned, and this list can be as the input of \code{\link{MetaProgram}}. Otherwise, only a Heatmap will be returned.
#' \describe{
#'   \item{Heatmap}{A Heatmap object generated by the \code{ComplexHeatmap::\link[ComplexHeatmap]{pheatmap}} function.}
#'   \item{Cluster}{If \code{cut.num} is provided, a named numeric vector containing the cluster assignments for each row in the heatmap.}
#' }
#'
#' @examples
#' # Sample transcriptional programs
#' set.seed(123)
#' ls_pg <- lapply(1:50, function(i){
#'   paste0('g',sample(1:100,20))
#' })
#'
#' names(ls_pg) <- paste0('PG_',1:50)
#'
#' # Generate the ovelap matrix
#' ovlp1 <- OverlapMat(ls_pg)
#' # Generate cluster plot
#' hm1 <- OvlpHeatmap(ovlp1, cut.num = 3)
#' print(hm1)
#'
#' # Use the Jaccard similarity to cluster
#' ovlp2 <- OverlapMat(ls_pg, Jaccard = TRUE)
#' hm2 <- OvlpHeatmap(ovlp2, cut.num = 3, breaks = c(0,1))
#' print(hm2)
#'
#' @seealso \code{ComplexHeatmap::\link[ComplexHeatmap]{pheatmap}} to customize the heatmap appearance.
#' @seealso \code{stats::\link[stats]{hclust}} for hierarchical clustering based on the specified number of clusters.
#' @importFrom ComplexHeatmap pheatmap
#' @importFrom paletteer paletteer_d paletteer_c
#' @importFrom stats dist hclust as.dist cor setNames
#' @export
OvlpHeatmap = function(ovlp, cut.num = NA, border="grey",
                       method.clustering = "ward.D2",
                       distance.clustering = "Intersection", max.intersect = 50,
                       annotation = NULL, color.annotation = NULL,
                       cluster.name = 'MetaProgram', cluster.key = 'MP_',
                       name = 'Share Genes', show.colnames = FALSE, show.rownames = TRUE, 
                       breaks = 0:25, color = c('white',rev(as.character(paletteer::paletteer_c("viridis::magma", 32))[8:32])),...){
    
    if(distance.clustering == "Intersection"){
        res_dist = as.dist(max.intersect-ovlp)
    }else if(distance.clustering == "Jaccard"){
        res_dist = as.dist(1-ovlp)
    }else if(distance.clustering == "correlation"){
        res_dist = as.dist(1-cor(ovlp))
    }else{
        res_dist = dist(ovlp, method = distance.clustering)
    }
    
    res_hclust = hclust(res_dist, method = method.clustering)
    
    #indicate if the user cut.num is existing
    user_cut = FALSE
    if(!is.na(cut.num)){
        if(!is.numeric(cut.num)){stop('the cut.num should be numeric')}
        user_cut = TRUE
        cluster = cutree(res_hclust, cut.num)
        anno = data.frame(paste0(cluster.key, cluster))
        colnames(anno) = cluster.name
        if(cut.num <= 51 ){
            anno_color = as.character(paletteer_d("ggsci::default_igv"))[1:cut.num]
        }else{
            anno_color = as.character(paletteer_d("ggsci::default_igv", n = cut.num, type = 'continuous'))
        }
        anno_color = list(setNames(anno_color, unique(anno[[cluster.name]])))
        names(anno_color) = cluster.name
    }else{
        anno = anno_color = NA
    }
    
    
    if(!is.null(annotation)){
        anno = cbind(anno , annotation)
        anno_color = c(anno_color, color.annotation)
    }
    
    
    hm = ComplexHeatmap::pheatmap(ovlp, border=border, name = name,
                                  annotation_row = anno, annotation_colors = anno_color,
                                  cutree_rows=cut.num, cutree_cols=cut.num,
                                  show_colnames = show.colnames, show_rownames = show.rownames,
                                  cluster_rows = res_hclust,
                                  cluster_cols = res_hclust,
                                  breaks = breaks, color = color,...)
    
    if(user_cut){
        return(list(Heatmap = hm, Cluster = cluster[res_hclust$order]))
    }else{
        return(hm)
    }
}
